¡Hecho! Aquí tienes un **prompt listo para tu agente** (cópialo completo) para **aplicar los parches, compilar, configurar y ejecutar** el nuevo escáner en `ARBITRAGEXPLUS-II` **al pie de la letra**.

> Consejo: pégalo tal cual en tu orquestador/agente. No requiere decisiones humanas fuera de reemplazar las URLs WS y, si quieres, actualizar direcciones reales de tokens/pools.

---

## PROMPT PARA MI AGENTE

**Objetivo:**
Aplicar dos parches (`0001-scanners.patch`, `0002-config-and-script.patch`) al repositorio `ARBITRAGEXPLUS-II`, compilar el binario `mev-scanner`, crear/configurar `mev-scanner-config.json`, y ejecutar el escáner dirigido (EVENT_SWAP, BRIDGED_STABLE, TWAP), dejando todo validado con salida JSON.

**Pasos estrictos:**

1. **Preparación del entorno**

* Asegura Rust instalado (stable): `rustup default stable && rustc --version && cargo --version`.
* Ubícate en el root del repo ya clonado: `ARBITRAGEXPLUS-II/`.
* Crea rama de trabajo:
  `git checkout -b feat/scanners-directed`

2. **Crear y aplicar Patch 1 (escáner + binario)**

* Crea un archivo `0001-scanners.patch` con **este contenido EXACTO**:

```diff
diff --git a/rust-mev-engine/Cargo.toml b/rust-mev-engine/Cargo.toml
index 1111111..2222222 100644
--- a/rust-mev-engine/Cargo.toml
+++ b/rust-mev-engine/Cargo.toml
@@ -1,6 +1,34 @@
 [package]
 name = "rust-mev-engine"
 version = "0.1.0"
 edition = "2021"
 
+[features]
+# Conjunto mínimo para escaneo y utilidades (no toca tu binario actual)
+scanners = ["dep:tokio", "dep:serde", "dep:serde_json", "dep:eyre", "dep:petgraph"]
+# EVM (event scanner con ethers). Habilita WebSocket solo cuando lo necesites.
+evm = ["scanners", "dep:ethers"]
+
+[dependencies]
+# (tus deps existentes permanecen)
+tokio = { version = "1", features = ["rt-multi-thread","macros"], optional = true }
+serde = { version = "1", features = ["derive"], optional = true }
+serde_json = { version = "1", optional = true }
+eyre = { version = "0.6", optional = true }
+petgraph = { version = "0.6", optional = true }
+ethers = { version = "2", default-features = false, features = ["ws","rustls"], optional = true }
+
+[[bin]]
+name = "mev-scanner"
+path = "src/bin/mev_scanner.rs"
+required-features = ["scanners"]
+
diff --git a/rust-mev-engine/src/bin/mev_scanner.rs b/rust-mev-engine/src/bin/mev_scanner.rs
new file mode 100644
index 0000000..c1c1c1c
--- /dev/null
+++ b/rust-mev-engine/src/bin/mev_scanner.rs
@@ -0,0 +1,153 @@
+//! Binario de escaneo dirigido: EVENT_SWAP, BRIDGED_STABLE, TWAP
+//! No interfiere con tu binario principal. Ejecutar con:
+//! cargo run -p rust-mev-engine --bin mev-scanner --features scanners
+//! (para eventos EVM vía WS): --features evm
+
+use eyre::Result;
+use std::{fs::File, io::BufReader, time::Duration};
+use serde::Deserialize;
+
+#[derive(Debug, Deserialize, Clone)]
+struct AssetCfg { address: String, #[serde(default)] symbol: Option<String> }
+#[derive(Debug, Deserialize, Clone)]
+struct ChainCfg {
+    chain_id: u64,
+    name: String,
+    #[serde(default)] ws: Option<String>,
+    #[serde(default)] pools: Vec<String>,
+    #[serde(default)] assets: Vec<AssetCfg>,
+}
+#[derive(Debug, Deserialize)]
+struct ScanConfig {
+    chains: Vec<ChainCfg>,
+    #[serde(default)] bridgedGroups: std::collections::BTreeMap<String, Vec<String>>,
+    #[serde(default)] prioritizeDex: Vec<String>,
+}
+
+mod scanners;
+mod graph;
+mod sizing;
+
+#[tokio::main]
+async fn main() -> Result<()> {
+    // 1) Cargar configuración local (no toca tu config actual)
+    let path = std::env::var("MEV_SCANNER_CONFIG").unwrap_or_else(|_| "mev-scanner-config.json".to_string());
+    let cfg: ScanConfig = serde_json::from_reader(BufReader::new(File::open(&path)?))?;
+
+    // 2) BRIDGED STABLES ⇒ generar parejas (USDC vs USDC.e, USDbC, etc.) y loguear
+    let bridged = scanners::bridged_scanner::bridged_pairs(&cfg);
+    for (chain_id, a, b) in bridged {
+        println!("{}", serde_json::json!({
+            "ts": chrono::Utc::now().to_rfc3339(),
+            "reason": "BRIDGED_STABLE_PAIR",
+            "chain_id": chain_id,
+            "a": a, "b": b
+        }).to_string());
+    }
+
+    // 3) TWAP pools priorizados
+    let twap = scanners::twap_scanner::pick_twap_pools(&cfg);
+    for (chain_id, pool_addr) in twap {
+        println!("{}", serde_json::json!({
+            "ts": chrono::Utc::now().to_rfc3339(),
+            "reason": "TWAP_POOL_CANDIDATE",
+            "chain_id": chain_id,
+            "pool": pool_addr
+        }).to_string());
+    }
+
+    // 4) EVENTOS EVM por WS (opcional, solo si se compila con --features evm y hay WS)
+    #[cfg(feature = "evm")]
+    {
+        use scanners::event_scanner::EventScanner;
+        for ch in cfg.chains.iter().filter(|c| c.ws.is_some()) {
+            let ws = ch.ws.clone().unwrap();
+            // lanzar en tasks independientes para cada chain con WS
+            tokio::spawn(async move {
+                if let Ok(scanner) = EventScanner::connect(&ws).await {
+                    // Si no hay pools definidos, el scanner solo valida conexión
+                    let pools = ch.pools.iter().filter_map(|p| p.parse().ok()).collect::<Vec<ethers::types::Address>>();
+                    let _ = scanner.watch_pools(pools).await;
+                }
+            });
+        }
+        // Mantener vivo el proceso si se activó WS
+        tokio::time::sleep(Duration::from_secs(2)).await;
+    }
+
+    Ok(())
+}
+
diff --git a/rust-mev-engine/src/scanners/mod.rs b/rust-mev-engine/src/scanners/mod.rs
new file mode 100644
index 0000000..7777777
--- /dev/null
+++ b/rust-mev-engine/src/scanners/mod.rs
@@ -0,0 +1,5 @@
+pub mod bridged_scanner;
+pub mod twap_scanner;
+#[cfg(feature = "evm")]
+pub mod event_scanner;
+
diff --git a/rust-mev-engine/src/scanners/bridged_scanner.rs b/rust-mev-engine/src/scanners/bridged_scanner.rs
new file mode 100644
index 0000000..8888888
--- /dev/null
+++ b/rust-mev-engine/src/scanners/bridged_scanner.rs
@@ -0,0 +1,46 @@
+use std::collections::BTreeMap;
+use serde::Deserialize;
+
+#[derive(Debug, Deserialize)]
+pub struct AssetCfg { pub address: String, #[serde(default)] pub symbol: Option<String> }
+#[derive(Debug, Deserialize)]
+pub struct ChainCfg { pub chain_id: u64, pub assets: Vec<AssetCfg> }
+#[derive(Debug, Deserialize)]
+pub struct ScanConfig {
+    pub chains: Vec<ChainCfg>,
+    #[serde(default)] pub bridgedGroups: BTreeMap<String, Vec<String>>,
+}
+
+/// Devuelve todas las parejas de *misma familia* (p.ej., USDC vs USDC.e) por chain.
+pub fn bridged_pairs(cfg: &crate::ScanConfig) -> Vec<(u64, String, String)> {
+    let mut out = vec![];
+    // Construir set de símbolos permitidos por familia (USDC, USDbC, USDC.e, etc.)
+    let mut allow: BTreeMap<String, Vec<String>> = BTreeMap::new();
+    for (fam, variants) in cfg.bridgedGroups.iter() {
+        allow.insert(fam.to_uppercase(), variants.iter().map(|v| v.to_uppercase()).collect());
+    }
+    for ch in &cfg.chains {
+        // Agrupar assets por FAMILIA (si el símbolo está en alguna familia bridged)
+        let mut by_fam: BTreeMap<String, Vec<&AssetCfg>> = BTreeMap::new();
+        for a in &ch.assets {
+            if let Some(sym) = &a.symbol {
+                let s = sym.to_uppercase();
+                for (fam, variants) in allow.iter() {
+                    if variants.iter().any(|x| &s == x) {
+                        by_fam.entry(fam.clone()).or_default().push(a);
+                    }
+                }
+            }
+        }
+        for (_fam, veca) in by_fam {
+            for i in 0..veca.len() {
+                for j in (i+1)..veca.len() {
+                    out.push((ch.chain_id, veca[i].address.clone(), veca[j].address.clone()));
+                }
+            }
+        }
+    }
+    out
+}
+
diff --git a/rust-mev-engine/src/scanners/twap_scanner.rs b/rust-mev-engine/src/scanners/twap_scanner.rs
new file mode 100644
index 0000000..9999999
--- /dev/null
+++ b/rust-mev-engine/src/scanners/twap_scanner.rs
@@ -0,0 +1,31 @@
+use serde::Deserialize;
+
+#[derive(Debug, Deserialize, Clone)]
+pub struct ChainCfg {
+    pub chain_id: u64,
+    #[serde(default)] pub pools: Vec<String>,
+}
+#[derive(Debug, Deserialize)]
+pub struct ScanConfig {
+    pub chains: Vec<ChainCfg>,
+    #[serde(default)] pub prioritizeDex: Vec<String>,
+}
+
+/// Marca como candidatos los pools de las DEX priorizadas (TWAP/estable).
+/// Aquí solo propagamos direcciones que ya vengan en la config; el cruce real lo haces en tu engine.
+pub fn pick_twap_pools(cfg: &crate::ScanConfig) -> Vec<(u64, String)> {
+    let _dex_whitelist = cfg.prioritizeDex.iter().map(|s| s.to_lowercase()).collect::<Vec<_>>();
+    let mut out = vec![];
+    for ch in &cfg.chains {
+        for p in &ch.pools {
+            out.push((ch.chain_id, p.clone()));
+        }
+    }
+    out
+}
+
diff --git a/rust-mev-engine/src/scanners/event_scanner.rs b/rust-mev-engine/src/scanners/event_scanner.rs
new file mode 100644
index 0000000..aaaaaaa
--- /dev/null
+++ b/rust-mev-engine/src/scanners/event_scanner.rs
@@ -0,0 +1,61 @@
+#![cfg(feature = "evm")]
+use eyre::Result;
+use ethers::providers::{Provider, Ws};
+use ethers::types::{Filter, Address};
+use futures_util::StreamExt;
+
+pub struct EventScanner {
+    provider: Provider<Ws>,
+}
+
+impl EventScanner {
+    pub async fn connect(ws_url: &str) -> Result<Self> {
+        let provider = Provider::<Ws>::connect(ws_url).await?;
+        Ok(Self { provider })
+    }
+
+    /// Observa eventos Swap (UniswapV3-like). Si `pools` está vacío, solo valida la conexión.
+    pub async fn watch_pools(&self, pools: Vec<Address>) -> Result<()> {
+        if pools.is_empty() {
+            println!(r#"{{"reason":"EVENT_WS_OK"}}"#);
+            return Ok(())
+        }
+        let filter = Filter::new()
+            .address(pools)
+            .event("Swap(address,int256,int256,uint160,uint128,int24)");
+        let mut sub = self.provider.subscribe_logs(&filter).await?;
+        while let Some(Ok(log)) = sub.next().await {
+            println!("{}", serde_json::json!({
+                "ts": chrono::Utc::now().to_rfc3339(),
+                "reason": "EVENT_SWAP",
+                "pool": format!("{:?}", log.address)
+            }).to_string());
+        }
+        Ok(())
+    }
+}
+
diff --git a/rust-mev-engine/src/graph/bellman.rs b/rust-mev-engine/src/graph/bellman.rs
new file mode 100644
index 0000000..bbbbbbb
--- /dev/null
+++ b/rust-mev-engine/src/graph/bellman.rs
@@ -0,0 +1,79 @@
+//! Bellman-Ford para detectar ciclo negativo en pesos w = -ln(price_neto)
+//! edges: (u, v, w) con u,v ∈ [0..n)
+pub fn negative_cycle(edges: &[(usize,usize,f64)], n: usize) -> Option<Vec<usize>> {
+    let mut dist = vec![0.0; n];
+    let mut parent = vec![None; n];
+    let mut x = None;
+    for _ in 0..n {
+        x = None;
+        for &(u,v,w) in edges {
+            if dist[v] > dist[u] + w {
+                dist[v] = dist[u] + w;
+                parent[v] = Some(u);
+                x = Some(v);
+            }
+        }
+        if x.is_none() { break; }
+    }
+    // Si hubo relajación en la n-ésima iteración → hay ciclo
+    if let Some(mut v) = x {
+        for _ in 0..n { v = parent[v].unwrap(); }
+        let start = v;
+        let mut cyc = vec![start];
+        let mut u = parent[start].unwrap();
+        while u != start {
+            cyc.push(u);
+            u = parent[u].unwrap();
+        }
+        cyc.reverse();
+        return Some(cyc);
+    }
+    None
+}
+
diff --git a/rust-mev-engine/src/sizing/opt.rs b/rust-mev-engine/src/sizing/opt.rs
new file mode 100644
index 0000000..ccccccc
--- /dev/null
+++ b/rust-mev-engine/src/sizing/opt.rs
@@ -0,0 +1,33 @@
+//! Búsqueda de tamaño óptimo (grid search rápido)
+//! f(x) debe devolver PnL neto (incluye fees y gas).
+pub fn grid_search<F>(f: F, min: f64, max: f64, steps: usize) -> (f64, f64)
+where F: Fn(f64) -> f64 {
+    assert!(max > min && steps > 0);
+    let mut best_x = min;
+    let mut best_v = f(min);
+    let dx = (max - min) / steps as f64;
+    let mut x = min;
+    for _ in 0..=steps {
+        let v = f(x);
+        if v > best_v { best_v = v; best_x = x; }
+        x += dx;
+    }
+    (best_x, best_v)
+}
+
```

* Aplica el parche:
  `git apply --whitespace=fix 0001-scanners.patch`

3. **Crear y aplicar Patch 2 (config y script)**

* Crea el archivo `0002-config-and-script.patch` con **este contenido EXACTO**:

```diff
diff --git a/mev-scanner-config.json b/mev-scanner-config.json
new file mode 100644
index 0000000..d1d1d1d
--- /dev/null
+++ b/mev-scanner-config.json
@@ -0,0 +1,49 @@
+{
+  "//": "Config independiente para el binario mev-scanner (no pisa tu config actual)",
+  "chains": [
+    {
+      "chain_id": 8453,
+      "name": "base",
+      "ws": "wss://REEMPLAZA_AQUI_WS_BASE",
+      "pools": [
+        "0x0000000000000000000000000000000000000000"
+      ],
+      "assets": [
+        { "address": "0x0000000000000000000000000000000000000001", "symbol": "USDC" },
+        { "address": "0x0000000000000000000000000000000000000002", "symbol": "USDbC" }
+      ]
+    },
+    {
+      "chain_id": 42161,
+      "name": "arbitrum",
+      "ws": "wss://REEMPLAZA_AQUI_WS_ARBITRUM",
+      "pools": [],
+      "assets": [
+        { "address": "0x0000000000000000000000000000000000000003", "symbol": "USDC" },
+        { "address": "0x0000000000000000000000000000000000000004", "symbol": "USDC.e" }
+      ]
+    }
+  ],
+  "bridgedGroups": {
+    "USDC": ["USDC","USDbC","USDC.e"]
+  },
+  "prioritizeDex": ["aerodrome","velodrome","balancer","curve","uniswapv3"]
+}
diff --git a/scripts/run-mev-scanner.sh b/scripts/run-mev-scanner.sh
new file mode 100755
index 0000000..e2e2e2e
--- /dev/null
+++ b/scripts/run-mev-scanner.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env bash
+set -euo pipefail
+SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+REPO_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"
+
+# Permite sobreescribir el path de config con MEV_SCANNER_CONFIG
+export MEV_SCANNER_CONFIG="${MEV_SCANNER_CONFIG:-$REPO_ROOT/mev-scanner-config.json}"
+
+echo "[mev-scanner] using config: $MEV_SCANNER_CONFIG"
+cd "$REPO_ROOT/rust-mev-engine"
+
+# Solo escáner básico (bridged, twap, sin WS):
+cargo run --bin mev-scanner --features scanners
+
+# Para habilitar eventos EVM por WS (si ya configuraste las URLs):
+# cargo run --bin mev-scanner --features evm
+
```

* Aplica el parche:
  `git apply --whitespace=fix 0002-config-and-script.patch`

4. **Compilar**

* Formatea y compila con features mínimas del escáner:

  ```bash
  cd rust-mev-engine
  cargo fmt
  cargo build --bin mev-scanner --features scanners
  ```
* (Opcional WS EVM) Solo si voy a usar WebSocket on-chain:

  ```bash
  cargo build --bin mev-scanner --features evm
  ```

5. **Configurar direcciones y WS**

* Edita `mev-scanner-config.json` y reemplaza:

  * `wss://REEMPLAZA_AQUI_WS_BASE` y `wss://REEMPLAZA_AQUI_WS_ARBITRUM` por endpoints **WSS** válidos de tu proveedor (p. ej., Alchemy/Ankr/Infura).
  * Las direcciones de `assets` y `pools` por direcciones reales si quieres señales inmediatas (USDC/USDC.e en Arbitrum; USDC/USDbC en Base).
  * Si aún no tienes WSS, deja los campos y **ejecuta el modo sin WS** (solo bridged + twap).

6. **Ejecución**

* Desde la raíz del repo:

  ```bash
  chmod +x scripts/run-mev-scanner.sh
  ./scripts/run-mev-scanner.sh
  ```
* **Salida esperada (líneas JSON)**: deben verse eventos con `reason`:

  * `BRIDGED_STABLE_PAIR`
  * `TWAP_POOL_CANDIDATE`
  * (si WS activo y pools definidos) `EVENT_SWAP` o `EVENT_WS_OK`

7. **Validación**

* Verifica que el proceso finaliza **sin errores** y emite al menos:

  * ≥1 línea con `BRIDGED_STABLE_PAIR`
  * ≥1 línea con `TWAP_POOL_CANDIDATE`
* Captura 10 líneas de ejemplo a `logs/mev-scanner.sample.jsonl`:

  ```bash
  mkdir -p logs
  ./scripts/run-mev-scanner.sh | head -n 10 > logs/mev-scanner.sample.jsonl || true
  ```

8. **Commit y push**

```bash
git add .
git commit -m "feat(scanner): add directed scanners (bridged, twap, events) + mev-scanner bin"
git push --set-upstream origin feat/scanners-directed
```

9. **Criterios de aceptación (obligatorios)**

* Los dos parches aplicados sin `*.rej`.
* `cargo build --bin mev-scanner --features scanners` **OK**.
* Archivo `mev-scanner-config.json` presente en raíz.
* Script `scripts/run-mev-scanner.sh` ejecuta y produce JSON con `reason`.
* (Opcional) Con WS configurado y pools reales: aparece `EVENT_SWAP`.

**Fin del prompt. Ejecuta exactamente como está.**
