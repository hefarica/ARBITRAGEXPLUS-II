¡Perfecto! Reinicio el diseño **100% en Rust** (sin mocks ni hardcodes) para que el **Backend MEV Engine manager** y el **Engine** corran con latencia mínima. Te dejo un **starter pack** listo para compilar y extender: endpoints Axum, validación, persistencia con SQLx (PostgreSQL), hot-reload del `SharedConfig`, `DataProvider` con ethers, scanner 2/3 legs y script e2e.

> Todo fluye **desde arrays JSON** enviados por el frontend → **DB** → **apply** al Engine (hot-reload) → **scan**.
> Nada de datos “fijos”: todo entra por API/DB/ENV.

---

# Workspace (Cargo)

```toml
# Cargo.toml (raíz)
[workspace]
members = ["crates/mev-config", "crates/mev-api", "crates/mev-engine", "crates/provider"]

[profile.release]
lto = "thin"
codegen-units = 1
opt-level = "z"
```

---

# 1) Tipos + Validación (crate `mev-config`)

```rust
// crates/mev-config/src/lib.rs
use serde::{Deserialize, Serialize};
use anyhow::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub version: String,
    pub chains: Vec<ChainConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChainConfig {
    pub chain_id: u64,
    pub alias: String,
    pub wnative: String, // addr
    pub rpc_pool: RpcPool,
    pub dexes: Vec<DexCfg>,
    pub assets: Vec<Asset>,
    pub pools: Vec<Pool>,
    pub policies: Policies,
    #[serde(default)]
    pub ref_pools: Vec<RefPool>,
    #[serde(default)]
    pub blocklists: Blocklists,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RpcPool { pub wss: Vec<String>, pub https: Vec<String> }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DexCfg { pub dex_id: String, pub enabled: bool, #[serde(default)] pub quoter: Option<String> }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Asset { pub chain_id: u64, pub address: String, #[serde(default)] pub symbol: Option<String>, #[serde(default)] pub decimals: Option<u8> }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pool { pub dex_id: String, pub pair_address: String, pub fee_bps: u32 }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policies {
    pub roi_min_bps: i32,
    pub gas_safety_bps: u32,
    pub slippage_bps: u32,
    pub size_grid: SizeGrid,
    pub cap_pct_tvl: f64,
    pub bundle_max_blocks: u32,
    pub allow_bridged_symbols: Option<bool>,
    pub gas_units_hint_roundtrip_v2: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SizeGrid { pub min: f64, pub max: f64, pub steps: u32 }

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RefPool { pub token: String, pub pair_address: String, pub fee_bps: u32 }

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Blocklists { pub pools: Vec<String>, pub tokens: Vec<String> }

impl Config {
    pub fn validate_schema(&self) -> Result<()> {
        if self.chains.is_empty() { bail!("NO_CHAINS") }
        for ch in &self.chains {
            if ch.rpc_pool.https.iter().collect::<std::collections::HashSet<_>>().len() < 2 { bail!("RPC_QUORUM_HTTPS chain={}", ch.chain_id) }
            if ch.rpc_pool.wss.iter().collect::<std::collections::HashSet<_>>().len()   < 2 { bail!("RPC_QUORUM_WSS chain={}", ch.chain_id) }
            if !(ch.policies.size_grid.min < ch.policies.size_grid.max) || ch.policies.size_grid.steps < 3 { bail!("INVALID_SIZE_GRID chain={}", ch.chain_id) }

            // dedup pools por dex|pair
            let mut seen = std::collections::HashSet::new();
            for p in &ch.pools {
                let k = format!("{}|{}", p.dex_id, p.pair_address.to_lowercase());
                if !seen.insert(k) { bail!("DUP_POOL chain={}", ch.chain_id) }
                if p.fee_bps == 0 { bail!("INVALID_FEE_BPS chain={}", ch.chain_id) }
                if ch.blocklists.pools.iter().any(|b| b.eq_ignore_ascii_case(&p.pair_address)) {
                    bail!("BLOCKLIST_POOL {}", p.pair_address)
                }
            }

            if ch.policies.allow_bridged_symbols == Some(false) {
                // Solo ejemplo: no mezclar usdc nativo vs bridged si símbolos lo sugieren.
                let syms: Vec<String> = ch.assets.iter().filter_map(|a| a.symbol.clone()).map(|s| s.to_lowercase()).collect();
                let has_usdc = syms.iter().any(|s| s == "usdc");
                let has_bridged = syms.iter().any(|s| s.contains("usdc.e") || s.contains("usdbc") || s.contains("bridged"));
                if has_usdc && has_bridged { bail!("BRIDGED_STABLES_FORBIDDEN chain={}", ch.chain_id) }
            }
        }
        Ok(())
    }
}

pub fn size_grid(min: f64, max: f64, steps: u32) -> Vec<f64> {
    assert!(steps >= 2 && min > 0.0 && max > min);
    let r = (max/min).powf(1.0/((steps-1) as f64));
    let mut v = Vec::with_capacity(steps as usize);
    let mut x = min;
    for _ in 0..steps { v.push(x); x *= r; }
    v
}
```

---

# 2) Backend Manager (crate `mev-api`) — Axum + SQLx + WS + Hot-reload

## SQL (migraciones)

```sql
-- db/migrations/001_init.sql
CREATE TABLE IF NOT EXISTS config_snapshots (
  version     TEXT PRIMARY KEY,
  payload     JSONB NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS config_active (
  id          INT PRIMARY KEY DEFAULT 1,
  version     TEXT NOT NULL,
  payload     JSONB NOT NULL,
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS assets (
  chain_id    BIGINT NOT NULL,
  address     TEXT   NOT NULL,
  symbol      TEXT,
  decimals    INT,
  PRIMARY KEY (chain_id, address)
);

CREATE TABLE IF NOT EXISTS pools (
  chain_id     BIGINT NOT NULL,
  dex_id       TEXT   NOT NULL,
  pair_address TEXT   NOT NULL,
  fee_bps      INT    NOT NULL,
  PRIMARY KEY (chain_id, dex_id, pair_address)
);

CREATE TABLE IF NOT EXISTS ref_pools (
  chain_id     BIGINT NOT NULL,
  token        TEXT   NOT NULL,
  pair_address TEXT   NOT NULL,
  fee_bps      INT    NOT NULL,
  dex_id       TEXT   NOT NULL,
  score        NUMERIC,
  source       TEXT,
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, token)
);
```

## Estado compartido & WS

```rust
// crates/mev-api/src/state.rs
use std::{sync::Arc};
use tokio::sync::{RwLock, broadcast};
use mev_config::Config;
use sqlx::PgPool;

#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
    pub shared_config: Arc<RwLock<Option<Config>>>,
    pub ws_tx: broadcast::Sender<String>,
}
```

## Builder: reconstruir Config desde DB (sin hardcodes)

```rust
// crates/mev-api/src/config_builder.rs
use anyhow::*;
use serde_json::json;
use sqlx::PgPool;
use mev_config::{Config, ChainConfig, RpcPool, DexCfg, Asset, Pool, Policies, RefPool, Blocklists};

pub async fn build_config_from_db(db: &PgPool) -> Result<Config> {
    // Supón que tienes tablas chains, dexes, policies, rpc_endpoints (diseña a tu gusto)
    // Aquí solo se ejemplifica leyendo lo esencial sin hardcodes.
    let chains: Vec<(i64, String, String)> = sqlx::query_as(
        "SELECT chain_id, alias, wnative FROM chains WHERE enabled = true"
    ).fetch_all(db).await?;

    let mut out = Config { version: chrono::Utc::now().to_rfc3339(), chains: vec![] };

    for (chain_id_i, alias, wnative) in chains {
        let chain_id = chain_id_i as u64;

        let (https, wss): (Vec<String>, Vec<String>) = {
            let https: Vec<(String,)> = sqlx::query_as(
                "SELECT url FROM rpc_endpoints WHERE chain_id=$1 AND kind='https' AND enabled=true"
            ).bind(chain_id_i).fetch_all(db).await?;
            let wss: Vec<(String,)> = sqlx::query_as(
                "SELECT url FROM rpc_endpoints WHERE chain_id=$1 AND kind='wss' AND enabled=true"
            ).bind(chain_id_i).fetch_all(db).await?;
            (https.into_iter().map(|x| x.0).collect(), wss.into_iter().map(|x| x.0).collect())
        };

        let dexes: Vec<DexCfg> = sqlx::query_as::<_, (String, bool, Option<String>)>(
            "SELECT dex_id, enabled, quoter FROM dexes WHERE chain_id=$1"
        ).bind(chain_id_i).fetch_all(db).await?
         .into_iter().map(|(dex_id, enabled, quoter)| DexCfg{dex_id, enabled, quoter}).collect();

        let assets: Vec<Asset> = sqlx::query_as::<_, (i64, String, Option<String>, Option<i32>)>(
            "SELECT chain_id, address, symbol, decimals FROM assets WHERE chain_id=$1"
        ).bind(chain_id_i).fetch_all(db).await?
         .into_iter().map(|(cid, addr, sym, dec)| Asset {
            chain_id: cid as u64, address: addr.to_lowercase(), symbol: sym, decimals: dec.map(|d| d as u8)
         }).collect();

        let pools: Vec<Pool> = sqlx::query_as::<_, (String, String, i32)>(
            "SELECT dex_id, pair_address, fee_bps FROM pools WHERE chain_id=$1"
        ).bind(chain_id_i).fetch_all(db).await?
         .into_iter().map(|(dex_id, pair_address, fee_bps)| Pool{
            dex_id, pair_address: pair_address.to_lowercase(), fee_bps: fee_bps as u32
         }).collect();

        let policies: Policies = {
            let row: (i32,u32,u32,f64,u32,Option<bool>,Option<i64>) = sqlx::query_as(
              "SELECT roi_min_bps, gas_safety_bps, slippage_bps, cap_pct_tvl, bundle_max_blocks, allow_bridged_symbols, gas_units_hint_roundtrip_v2
               FROM policies WHERE chain_id=$1"
            ).bind(chain_id_i).fetch_one(db).await?;
            Policies{
                roi_min_bps: row.0, gas_safety_bps: row.1, slippage_bps: row.2,
                size_grid: { // lee size_grid de otra tabla si quieres; ejemplo fijo por DB:
                    let sg: (f64,f64,i32) = sqlx::query_as("SELECT min,max,steps FROM size_grid WHERE chain_id=$1")
                        .bind(chain_id_i).fetch_one(db).await?;
                    mev_config::SizeGrid{ min: sg.0, max: sg.1, steps: sg.2 as u32 }
                },
                cap_pct_tvl: row.3, bundle_max_blocks: row.4,
                allow_bridged_symbols: row.5, gas_units_hint_roundtrip_v2: row.6.map(|v| v as u64),
            }
        };

        let ref_pools: Vec<RefPool> = sqlx::query_as::<_, (String, String, i32)>(
            "SELECT token, pair_address, fee_bps FROM ref_pools WHERE chain_id=$1"
        ).bind(chain_id_i).fetch_all(db).await?
         .into_iter().map(|(token, pair_address, fee_bps)| RefPool{
            token: token.to_lowercase(), pair_address: pair_address.to_lowercase(), fee_bps: fee_bps as u32
         }).collect();

        let blocklists = Blocklists{
            pools: sqlx::query_as::<_, (String,)>("SELECT address FROM blocklist_pools WHERE chain_id=$1")
                .bind(chain_id_i).fetch_all(db).await?.into_iter().map(|x| x.0).collect(),
            tokens: sqlx::query_as::<_, (String,)>("SELECT address FROM blocklist_tokens WHERE chain_id=$1")
                .bind(chain_id_i).fetch_all(db).await?.into_iter().map(|x| x.0).collect(),
        };

        out.chains.push(ChainConfig{
            chain_id, alias, wnative: wnative.to_lowercase(),
            rpc_pool: RpcPool{ https, wss }, dexes, assets, pools, policies, ref_pools, blocklists
        });
    }

    out.validate_schema()?;
    Ok(out)
}
```

## `auto_save_and_reload` central

```rust
// crates/mev-api/src/engine_api.rs
use anyhow::*;
use axum::extract::State;
use sqlx::PgPool;
use crate::state::AppState;
use crate::config_builder::build_config_from_db;
use mev_config::Config;

pub async fn engine_validate(cfg: &Config) -> Result<()> {
    // Validación canónica del Engine (en este diseño, el Engine comparte el mismo crate mev-config y ejecuta mismas reglas).
    cfg.validate_schema()
}

pub async fn engine_apply(state: &AppState, cfg: &Config) -> Result<()> {
    // Hot-reload in-memory: actualiza SharedConfig
    {
        let mut guard = state.shared_config.write().await;
        *guard = Some(cfg.clone());
    }
    Ok(())
}

pub async fn save_snapshot(db: &PgPool, cfg: &Config) -> Result<()> {
    let payload = serde_json::to_value(cfg)?;
    let version = &cfg.version;
    sqlx::query("INSERT INTO config_snapshots(version, payload) VALUES ($1,$2)")
        .bind(version).bind(&payload).execute(db).await?;
    sqlx::query("INSERT INTO config_active(id, version, payload, updated_at) VALUES (1,$1,$2,now()) \
                 ON CONFLICT (id) DO UPDATE SET version=$1, payload=$2, updated_at=now()")
        .bind(version).bind(&payload).execute(db).await?;
    Ok(())
}

pub async fn auto_save_and_reload(state: &AppState, reason: &str) -> Result<Config> {
    let cfg = build_config_from_db(&state.db).await?;
    engine_validate(&cfg).await?;
    engine_apply(state, &cfg).await?;
    save_snapshot(&state.db, &cfg).await?;
    let _ = state.ws_tx.send(format!(r#"{{"type":"config.applied","version":"{}","reason":"{}"}}"#, cfg.version, reason));
    Ok(cfg)
}
```

## Endpoint `POST /api/engine/assets/upsert` (sin hardcodes, con reload)

```rust
// crates/mev-api/src/routes_assets.rs
use axum::{routing::post, Router, Json, extract::State};
use serde::Deserialize;
use anyhow::*;
use crate::state::AppState;
use sqlx::Acquire;

#[derive(Deserialize)]
struct UpsertAssets { assets: Vec<AssetIn> }
#[derive(Deserialize)]
struct AssetIn { chainId: u64, address: String, symbol: Option<String>, decimals: Option<u8> }

pub fn router() -> Router<AppState> {
    Router::new().route("/api/engine/assets/upsert", post(upsert_assets))
}

async fn upsert_assets(
    State(state): State<AppState>,
    Json(payload): Json<UpsertAssets>
) -> Result<Json<serde_json::Value>, (axum::http::StatusCode, String)> {
    if payload.assets.is_empty() {
        return Err((axum::http::StatusCode::BAD_REQUEST, "EMPTY_ASSETS".into()));
    }
    let mut tx = state.db.begin().await.map_err(internal)?;

    for a in payload.assets {
        if a.chainId == 0 || a.address.is_empty() {
            return Err((axum::http::StatusCode::BAD_REQUEST, "MISSING_FIELDS".into()));
        }
        let addr = a.address.to_lowercase();
        sqlx::query("INSERT INTO assets(chain_id,address,symbol,decimals) VALUES ($1,$2,$3,$4)\n\
                     ON CONFLICT (chain_id,address) DO UPDATE SET symbol=$3, decimals=$4")
            .bind(a.chainId as i64)
            .bind(&addr)
            .bind(&a.symbol)
            .bind(a.decimals.map(|v| v as i32))
            .execute(&mut *tx).await.map_err(internal)?;
    }
    tx.commit().await.map_err(internal)?;

    // (opcional) recomputeRefPools(chainId) por cada chain afectada (implementa en Rust también)
    // for chain_id in chain_ids_impactados { recompute_ref_pools(state.db.clone(), chain_id).await.ok(); }

    let cfg = crate::engine_api::auto_save_and_reload(&state, "assets.upsert").await
        .map_err(internal)?;
    Ok(Json(serde_json::json!({ "ok": true, "version": cfg.version })))
}

fn internal<E: std::fmt::Display>(e: E) -> (axum::http::StatusCode, String) {
    (axum::http::StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
}
```

## Server Axum + WS

```rust
// crates/mev-api/src/main.rs
use axum::{Router, routing::{get}, extract::State, response::IntoResponse};
use sqlx::postgres::PgPoolOptions;
use std::{net::SocketAddr, sync::Arc};
use tokio::sync::{RwLock, broadcast};
use mev_config::Config;

mod state; mod config_builder; mod engine_api; mod routes_assets;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let db_url = std::env::var("DATABASE_URL")?;
    let bind = std::env::var("MEV_API_BIND").unwrap_or_else(|_| "127.0.0.1:18080".into());
    let pool = PgPoolOptions::new().max_connections(10).connect(&db_url).await?;

    let (tx, _rx) = broadcast::channel::<String>(128);
    let shared_config = Arc::new(RwLock::new(None::<Config>));
    let state = state::AppState{ db: pool, shared_config, ws_tx: tx.clone() };

    let app = Router::new()
        .merge(routes_assets::router())
        .route("/config", get(get_config))
        .route("/ws", get(ws_handler))
        .with_state(state.clone());

    let addr: SocketAddr = bind.parse()?;
    println!("mev-api listening on {}", addr);
    axum::Server::bind(&addr).serve(app.into_make_service()).await?;
    Ok(())
}

async fn get_config(State(state): State<state::AppState>) -> impl IntoResponse {
    let g = state.shared_config.read().await;
    if let Some(cfg) = &*g {
        (axum::http::StatusCode::OK, axum::Json(cfg))
    } else {
        (axum::http::StatusCode::SERVICE_UNAVAILABLE, "NO_ACTIVE_CONFIG")
    }
}

async fn ws_handler(
    State(state): State<state::AppState>,
    ws: axum::extract::WebSocketUpgrade
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| async move {
        use axum::extract::ws::{Message, WebSocket};
        let mut rx = state.ws_tx.subscribe();
        let (mut sender, mut _recv) = socket.split();
        while let Ok(msg) = rx.recv().await {
            let _ = sender.send(Message::Text(msg)).await;
        }
    })
}
```

---

# 3) Provider (crate `provider`) — ethers-rs, sin hardcodes

```rust
// crates/provider/src/lib.rs
use anyhow::*;
use async_trait::async_trait;
use ethers::prelude::*;
use std::collections::HashMap;

#[async_trait]
pub trait DataProvider: Send + Sync {
    async fn block_number(&self, chain_id: u64) -> Result<u64>;
    async fn gas_price_wei(&self, chain_id: u64) -> Result<u128>;

    async fn pair_tokens(&self, chain_id: u64, pair: Address) -> Result<(Address,Address)>; // V2 interface
    async fn v2_reserves(&self, chain_id: u64, pair: Address) -> Result<(U256, U256)>;

    async fn erc20_decimals(&self, chain_id: u64, token: Address) -> Result<u8>;

    async fn v3_slot0(&self, chain_id: u64, pool: Address) -> Result<(U256, i32)>;
    async fn v3_liquidity(&self, chain_id: u64, pool: Address) -> Result<U256>;

    async fn v3_quote_exact_input_single(
        &self, chain_id: u64, quoter: Address, token_in: Address, token_out: Address,
        amount_in: U256, fee: u32, sqrt_price_limit_x96: Option<U256>
    ) -> Result<(U256, U256, u32, U256)>;

    async fn v3_quote_exact_output_single(
        &self, chain_id: u64, quoter: Address, token_in: Address, token_out: Address,
        amount_out: U256, fee: u32, sqrt_price_limit_x96: Option<U256>
    ) -> Result<(U256, U256, u32, U256)>;
}

pub struct EthersProvider { providers: HashMap<u64, Provider<Http>> }

impl EthersProvider {
    pub fn from_cfg(cfg: &mev_config::Config) -> Result<Self> {
        let mut map = HashMap::new();
        for ch in &cfg.chains {
            let url = ch.rpc_pool.https.first()
                .ok_or_else(|| anyhow!("MISSING_RPC_HTTPS chain={}", ch.chain_id))?;
            let p = Provider::<Http>::try_from(url.as_str())
                .map_err(|e| anyhow!("INVALID_RPC_URL chain={} {}", ch.chain_id, e))?;
            map.insert(ch.chain_id, p);
        }
        Ok(Self{ providers: map })
    }
    fn p(&self, chain_id: u64) -> Result<&Provider<Http>> {
        self.providers.get(&chain_id).ok_or_else(|| anyhow!("NO_PROVIDER:{}", chain_id))
    }
}

abigen!(UniswapV2Pair, r#"[ function token0() view returns (address)
                            function token1() view returns (address)
                            function getReserves() view returns (uint112,uint112,uint32) ]"#);
abigen!(Erc20, r#"[ function decimals() view returns (uint8) ]"#);
abigen!(UniV3Pool, r#"[ function slot0() view returns (uint160,int24,uint16,uint16,uint16,uint8,bool)
                        function liquidity() view returns (uint128) ]"#);
abigen!(QuoterV2, r#"[ function quoteExactInputSingle(address,address,uint256,uint24,uint160)
                       returns (uint256,uint160,uint32,uint256)
                       function quoteExactOutputSingle(address,address,uint256,uint24,uint160)
                       returns (uint256,uint160,uint32,uint256) ]"#);

#[async_trait]
impl DataProvider for EthersProvider {
    async fn block_number(&self, chain_id: u64) -> Result<u64> {
        Ok(self.p(chain_id)?.get_block_number().await?.as_u64())
    }
    async fn gas_price_wei(&self, chain_id: u64) -> Result<u128> {
        Ok(self.p(chain_id)?.get_gas_price().await?.as_u128())
    }
    async fn pair_tokens(&self, chain_id: u64, pair: Address) -> Result<(Address,Address)> {
        let c = UniswapV2Pair::new(pair, self.p(chain_id)?.clone());
        let (t0, t1) = tokio::try_join!(c.token0(), c.token1())?;
        Ok((t0, t1))
    }
    async fn v2_reserves(&self, chain_id: u64, pair: Address) -> Result<(U256,U256)> {
        let c = UniswapV2Pair::new(pair, self.p(chain_id)?.clone());
        let (r0, r1, _) = c.get_reserves().call().await?;
        Ok((U256::from(r0), U256::from(r1)))
    }
    async fn erc20_decimals(&self, chain_id: u64, token: Address) -> Result<u8> {
        let c = Erc20::new(token, self.p(chain_id)?.clone());
        Ok(c.decimals().call().await?)
    }
    async fn v3_slot0(&self, chain_id: u64, pool: Address) -> Result<(U256,i32)> {
        let c = UniV3Pool::new(pool, self.p(chain_id)?.clone());
        let (sp, tick, ..) = c.slot0().call().await?;
        Ok((U256::from(sp), tick as i32))
    }
    async fn v3_liquidity(&self, chain_id: u64, pool: Address) -> Result<U256> {
        let c = UniV3Pool::new(pool, self.p(chain_id)?.clone());
        Ok(U256::from(c.liquidity().call().await?))
    }
    async fn v3_quote_exact_input_single(&self, chain_id:u64, quoter: Address, ti: Address, to: Address, ai: U256, fee:u32, lim:Option<U256>) -> Result<(U256,U256,u32,U256)> {
        let q = QuoterV2::new(quoter, self.p(chain_id)?.clone());
        let (o, sp_after, ticks, gas_est) = q.quote_exact_input_single(ti, to, ai, fee as u32, lim.unwrap_or_default().as_u160()).call().await?;
        Ok((o, U256::from(sp_after), ticks, gas_est))
    }
    async fn v3_quote_exact_output_single(&self, chain_id:u64, quoter: Address, ti: Address, to: Address, ao: U256, fee:u32, lim:Option<U256>) -> Result<(U256,U256,u32,U256)> {
        let q = QuoterV2::new(quoter, self.p(chain_id)?.clone());
        let (i, sp_after, ticks, gas_est) = q.quote_exact_output_single(ti, to, ao, fee as u32, lim.unwrap_or_default().as_u160()).call().await?;
        Ok((i, U256::from(sp_after), ticks, gas_est))
    }
}
```

---

# 4) Engine / Scanner (crate `mev-engine`) — 2 y 3 legs, netPnL con gas

```rust
// crates/mev-engine/src/lib.rs
use anyhow::*;
use serde::Serialize;
use mev_config::{Config, size_grid};
use provider::DataProvider;
use ethers::types::Address;
use std::str::FromStr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone, Serialize)]
pub struct AttemptLog {
    ts_ms: u128, block: u64, chain_id: u64,
    route: Vec<String>, size_in: f64, quote_out: f64,
    gas_units: u64, gas_gwei: f64, net_pnl: f64, ok: bool,
    reason: Option<String>
}

fn now_ms() -> u128 { SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() }

fn v2_out_exact_in(dx: f64, rx: f64, ry: f64, fee_bps: u32) -> f64 {
    let f = 1.0 - (fee_bps as f64 / 10_000.0);
    let dx_f = dx * f;
    (dx_f * ry) / (rx + dx_f)
}

fn profit_net(input: f64, output: f64, gas_in_input: f64, safety_bps: u32) -> f64 {
    let safety = input * (safety_bps as f64 / 10_000.0);
    (output - input) - gas_in_input - safety
}

async fn decimals<P: DataProvider>(p:&P, chain: u64, a: Address, b: Address) -> Result<(f64,f64)> {
    let (da, db) = tokio::try_join!(p.erc20_decimals(chain, a), p.erc20_decimals(chain, b))?;
    Ok(((10u128.pow(da as u32)) as f64, (10u128.pow(db as u32)) as f64))
}

/// Costo de gas en token de entrada usando ref_pools[] (si existe), fallback a pools[]
async fn gas_cost_in_input_from_cfg<P: DataProvider>(
    p:&P, ch:&mev_config::ChainConfig, input_token: Address
) -> Result<(u64,f64)> {
    let wnative = Address::from_str(&ch.wnative)?;
    let candidates: Vec<(Address, u32)> = {
        let mut v = vec![];
        // ref_pools preferidos
        for r in &ch.ref_pools {
            if Address::from_str(&r.token).ok() == Some(input_token) {
                v.push((Address::from_str(&r.pair_address)?, r.fee_bps));
            }
        }
        if v.is_empty() {
            for p0 in &ch.pools {
                v.push((Address::from_str(&p0.pair_address)?, p0.fee_bps));
            }
        }
        v
    };

    let gas_price_wei = p.gas_price_wei(ch.chain_id).await? as f64;
    for (pair, fee) in candidates {
        let (t0, t1) = p.pair_tokens(ch.chain_id, pair).await?;
        if !((t0==wnative && t1==input_token) || (t0==input_token && t1==wnative)) { continue; }
        let (r0, r1) = p.v2_reserves(ch.chain_id, pair).await?;
        let (s0, s1) = decimals(p, ch.chain_id, t0, t1).await?;
        let rx = (if t0==wnative { r0 } else { r1 }).to::<f64>() / (if t0==wnative { s0 } else { s1 });
        let ry = (if t0==wnative { r1 } else { r0 }).to::<f64>() / (if t0==wnative { s1 } else { s0 });
        let fee_bps = fee;
        let fee_f = 1.0 - (fee_bps as f64 / 10_000.0);
        let eth_to_input = (ry / rx) * fee_f; // marginal
        return Ok((gas_price_wei as u64, eth_to_input));
    }
    bail!("NO_REF_POOL_WNATIVE_INPUT")
}

/// Escaneo 2-legs (inter-DEX) por par lógico V2 (rápido). Extiende a 3-legs encadenando v2_out_exact_in.
pub async fn scan_block_v2<P: DataProvider>(p:&P, cfg:&Config) -> Result<Vec<AttemptLog>> {
    let mut attempts = vec![];
    for ch in &cfg.chains {
        let block = p.block_number(ch.chain_id).await?;
        let sizes = size_grid(ch.policies.size_grid.min, ch.policies.size_grid.max, ch.policies.size_grid.steps);
        let safety_bps = ch.policies.gas_safety_bps;
        let gas_hint = ch.policies.gas_units_hint_roundtrip_v2.ok_or_else(|| anyhow::anyhow!("MISSING gas_units_hint_roundtrip_v2 chain={}", ch.chain_id))?;

        // Candidatos: misma pareja de tokens, distintos DEX; aquí inferimos por reserves
        // (Para simplicidad, interpreto pools como V2; para V3 usa Quoter al refinar)
        for i in 0..ch.pools.len() {
            for j in (i+1)..ch.pools.len() {
                let a = &ch.pools[i]; let b = &ch.pools[j];
                if a.dex_id == b.dex_id { continue; }
                // Descubrir tokens del par A
                let pa = Address::from_str(&a.pair_address)?; let pb = Address::from_str(&b.pair_address)?;
                let (t0a, t1a) = p.pair_tokens(ch.chain_id, pa).await?;
                let (r0a, r1a) = p.v2_reserves(ch.chain_id, pa).await?;
                let (s0a, s1a) = decimals(p, ch.chain_id, t0a, t1a).await?;
                let (rx1, ry1) = (r0a.to::<f64>()/s0a, r1a.to::<f64>()/s1a);

                // Par B
                let (t0b, t1b) = p.pair_tokens(ch.chain_id, pb).await?;
                let (r0b, r1b) = p.v2_reserves(ch.chain_id, pb).await?;
                let (s0b, s1b) = decimals(p, ch.chain_id, t0b, t1b).await?;
                let (rx2, ry2) = (r0b.to::<f64>()/s0b, r1b.to::<f64>()/s1b);

                // Suponemos input = token0 de A (puedes rotar tokens según canonicalidad)
                let input_token = t0a;
                let (_gp, eth_to_input) = gas_cost_in_input_from_cfg(p, ch, input_token).await?;
                let gas_price_wei = p.gas_price_wei(ch.chain_id).await? as f64;
                let gas_in_input = (gas_hint as f64) * gas_price_wei / 1e18 * eth_to_input;

                for &dx in &sizes {
                    // Ruta A->B ida y vuelta (2 legs)
                    let o1 = v2_out_exact_in(dx, rx1, ry1, a.fee_bps);
                    let o2 = v2_out_exact_in(o1, ry2, rx2, b.fee_bps);
                    let net = profit_net(dx, o2, gas_in_input, safety_bps);
                    attempts.push(AttemptLog{
                        ts_ms: now_ms(), block, chain_id: ch.chain_id,
                        route: vec![format!("{}:{}", a.dex_id, a.pair_address), format!("{}:{}", b.dex_id, b.pair_address)],
                        size_in: dx, quote_out: o2, gas_units: gas_hint, gas_gwei: gas_price_wei/1e9,
                        net_pnl: net, ok: net>0.0, reason: if net>0.0{None}else{Some("spread_insuficiente".into())}
                    });
                    // (Opcional) agregar B->A y rutas de 3 legs con tercer pool puente
                }
            }
        }
    }
    Ok(attempts)
}

pub fn write_jsonl(path: &str, rows: &[AttemptLog]) -> Result<()> {
    let mut f = std::fs::File::create(path)?;
    for r in rows { writeln!(f, "{}", serde_json::to_string(r)?)?; }
    Ok(())
}
```

---

# 5) Script e2e (upsert → reload → aplicar → WS)

```bash
# scripts/e2e.sh
#!/usr/bin/env bash
set -euo pipefail

: "${MEV_API_BASE:=http://127.0.0.1:18080}"

# 1) upsert assets desde arrays reales (ejemplo minimal; las direcciones las pone el frontend)
curl -sSf -X POST "$MEV_API_BASE/api/engine/assets/upsert" \
  -H 'content-type: application/json' \
  -d @assets.json | jq .

# 2) suscribirse a WS y ver config.applied (requiere websocat u otra; opcional)
# websocat ws://127.0.0.1:18080/ws &

# 3) leer /config del Engine
curl -sSf "$MEV_API_BASE/config" | jq .
echo "E2E OK"
```

> `assets.json` lo genera el frontend. Sin mocks: tú le pasas arrays reales.

---

# 6) Qué hace cada pieza (y cómo escala)

* **/api/engine/assets/upsert** (Axum + SQLx): persiste assets normalizados (lowercase), sin duplicados; recomputa `ref_pools` (opcional); llama **una sola** rutina `auto_save_and_reload()` → reconstruye arrays desde DB, valida (negocio y canónico), **aplica** a `SharedConfig` y emite `config.applied` por WS.
* **Validación triple**:

  * Front (forma: direcciones válidas, arrays no vacíos).
  * Backend (quorum RPC, `allow_bridged_symbols`, `size_grid`, blocklists, dedup `dex|pair`).
  * Engine (misma validación canónica en `mev-config`).
* **Provider (ethers)**: construye providers **desde** `cfg.chains[].rpc_pool.https` (no URLs hardcodeadas), lee reservas/decimales, `slot0` y Quoter V3.
* **Engine/Scanner**: 2 y 3 legs intra-chain (inter-DEX/intra-DEX), `netPnL` = out − in − gas_en_token − safety. Gas en token se convierte con **`ref_pools[]`** del `Config`. Logs JSONL **incluyen negativos** con `reason`.
  (Para producción: añade `eth_call` de la ruta completa y envío privado de bundles; el esqueleto ya está preparado.)
* **Hot-reload**: `SharedConfig` se actualiza atómicamente; todos los scanners leen la instantánea en memoria.

---

¿Quieres que además te deje un **endpoint `/api/engine/config/export`** (opcional `{ "dryRun": true }`) ya en Axum, y un **recompute_ref_pools** en Rust (equivalente al que propuse en TS) para cerrar el círculo?
