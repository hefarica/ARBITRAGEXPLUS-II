diff --git a/rust-mev-engine/Cargo.lock b/rust-mev-engine/Cargo.lock
index 357661d7..36bcd8a7 100644
--- a/rust-mev-engine/Cargo.lock
+++ b/rust-mev-engine/Cargo.lock
@@ -56,6 +56,15 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "ansi_term"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
+dependencies = [
+ "winapi",
+]
+
 [[package]]
 name = "anyhow"
 version = "1.0.100"
@@ -1799,7 +1808,7 @@ dependencies = [
  "lalrpop-util",
  "petgraph",
  "regex",
- "regex-syntax",
+ "regex-syntax 0.8.6",
  "string_cache",
  "term",
  "tiny-keccak",
@@ -1813,7 +1822,7 @@ version = "0.20.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "507460a910eb7b32ee961886ff48539633b788a36b65692b95f225b844c82553"
 dependencies = [
- "regex-automata",
+ "regex-automata 0.4.11",
 ]
 
 [[package]]
@@ -1866,6 +1875,15 @@ version = "0.4.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34080505efa8e45a4b816c349525ebe327ceaa8559756f0356cba97ef3bf7432"
 
+[[package]]
+name = "matchers"
+version = "0.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f099785f7595cc4b4553a174ce30dd7589ef93391ff414dbb67f62392b9e0ce1"
+dependencies = [
+ "regex-automata 0.1.10",
+]
+
 [[package]]
 name = "md-5"
 version = "0.10.6"
@@ -1900,6 +1918,9 @@ dependencies = [
  "serde",
  "serde_json",
  "tokio",
+ "tracing",
+ "tracing-subscriber 0.3.20",
+ "tracing-test",
  "uuid 1.18.1",
 ]
 
@@ -1936,6 +1957,15 @@ version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "650eef8c711430f1a879fdd01d4745a7deea475becfb90269c06775983bbf086"
 
+[[package]]
+name = "nu-ansi-term"
+version = "0.50.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d4a28e057d01f97e61255210fcff094d74ed0466038633e95017f5beb68e4399"
+dependencies = [
+ "windows-sys 0.52.0",
+]
+
 [[package]]
 name = "num-bigint"
 version = "0.4.6"
@@ -2412,7 +2442,7 @@ dependencies = [
  "rand 0.9.2",
  "rand_chacha 0.9.0",
  "rand_xorshift",
- "regex-syntax",
+ "regex-syntax 0.8.6",
  "unarray",
 ]
 
@@ -2553,8 +2583,17 @@ checksum = "8b5288124840bee7b386bc413c487869b360b2b4ec421ea56425128692f2a82c"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-automata",
- "regex-syntax",
+ "regex-automata 0.4.11",
+ "regex-syntax 0.8.6",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
+dependencies = [
+ "regex-syntax 0.6.29",
 ]
 
 [[package]]
@@ -2565,9 +2604,15 @@ checksum = "833eb9ce86d40ef33cb1306d8accf7bc8ec2bfea4355cbdebb3df68b40925cad"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-syntax",
+ "regex-syntax 0.8.6",
 ]
 
+[[package]]
+name = "regex-syntax"
+version = "0.6.29"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
+
 [[package]]
 name = "regex-syntax"
 version = "0.8.6"
@@ -2964,6 +3009,15 @@ dependencies = [
  "keccak",
 ]
 
+[[package]]
+name = "sharded-slab"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
+dependencies = [
+ "lazy_static",
+]
+
 [[package]]
 name = "shlex"
 version = "1.3.0"
@@ -3288,6 +3342,15 @@ dependencies = [
  "syn 2.0.106",
 ]
 
+[[package]]
+name = "thread_local"
+version = "1.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
+dependencies = [
+ "cfg-if",
+]
+
 [[package]]
 name = "time"
 version = "0.3.44"
@@ -3554,6 +3617,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
 dependencies = [
  "once_cell",
+ "valuable",
 ]
 
 [[package]]
@@ -3566,6 +3630,97 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "tracing-log"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f751112709b4e791d8ce53e32c4ed2d353565a795ce84da2285393f41557bdf2"
+dependencies = [
+ "log",
+ "once_cell",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-log"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
+dependencies = [
+ "log",
+ "once_cell",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-serde"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bc6b213177105856957181934e4920de57730fc69bf42c37ee5bb664d406d9e1"
+dependencies = [
+ "serde",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-subscriber"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e0d2eaa99c3c2e41547cfa109e910a68ea03823cccad4a0525dcbc9b01e8c71"
+dependencies = [
+ "ansi_term",
+ "chrono",
+ "lazy_static",
+ "matchers",
+ "regex",
+ "serde",
+ "serde_json",
+ "sharded-slab",
+ "smallvec",
+ "thread_local",
+ "tracing",
+ "tracing-core",
+ "tracing-log 0.1.4",
+ "tracing-serde",
+]
+
+[[package]]
+name = "tracing-subscriber"
+version = "0.3.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2054a14f5307d601f88daf0553e1cbf472acc4f2c51afab632431cdcd72124d5"
+dependencies = [
+ "nu-ansi-term",
+ "sharded-slab",
+ "smallvec",
+ "thread_local",
+ "tracing-core",
+ "tracing-log 0.2.0",
+]
+
+[[package]]
+name = "tracing-test"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a3b48778c2d401c6a7fcf38a0e3c55dc8e8e753cbd381044a8cdb6fd69a29f53"
+dependencies = [
+ "lazy_static",
+ "tracing-core",
+ "tracing-subscriber 0.2.25",
+ "tracing-test-macro",
+]
+
+[[package]]
+name = "tracing-test-macro"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c49adbab879d2e0dd7f75edace5f0ac2156939ecb7e6a1e8fa14e53728328c48"
+dependencies = [
+ "lazy_static",
+ "quote",
+ "syn 1.0.109",
+]
+
 [[package]]
 name = "try-lock"
 version = "0.2.5"
@@ -3706,6 +3861,12 @@ dependencies = [
  "wasm-bindgen",
 ]
 
+[[package]]
+name = "valuable"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"
+
 [[package]]
 name = "version_check"
 version = "0.9.5"
diff --git a/rust-mev-engine/Cargo.toml b/rust-mev-engine/Cargo.toml
index 8c60f31d..fc0c3157 100644
--- a/rust-mev-engine/Cargo.toml
+++ b/rust-mev-engine/Cargo.toml
@@ -36,6 +36,8 @@ reqwest = { version = "0.11", default-features = false, features = ["json", "rus
 petgraph = "0.6"
 ethers = { version = "2", default-features = false, features = ["ws", "rustls"] }
 futures-util = "0.3"
+tracing = "0.1"
+tracing-subscriber = "0.3"
 
 [[bin]]
 name = "mev-engine-minimal"
@@ -49,3 +51,7 @@ required-features = ["scanners"]
 [profile.dev]
 opt-level = 1
 debug = false
+
+[dev-dependencies]
+tracing-test = "0.1"
+
diff --git a/rust-mev-engine/src/database.rs b/rust-mev-engine/src/database.rs
index 90941be8..2f158252 100644
--- a/rust-mev-engine/src/database.rs
+++ b/rust-mev-engine/src/database.rs
@@ -79,6 +79,7 @@ pub struct Opportunity {
     pub gas_usd: f64,
     pub ts: i64,
     pub metadata: Option<serde_json::Value>,
+    pub kit_de_armado: Option<KitDeArmado>,
 }
 
 #[derive(Debug, Clone, Serialize, Deserialize, Queryable, Insertable)]
@@ -92,6 +93,8 @@ pub struct AssetSafety {
 
 #[derive(Debug, Clone, Serialize, Deserialize, Queryable, Insertable)]
 #[diesel(table_name = executions)]
+use crate::types::KitDeArmado;
+
 pub struct Execution {
     pub id: String,
     pub opportunity_id: Option<String>,
@@ -107,6 +110,7 @@ pub struct Execution {
     pub created_at: i64,
     pub updated_at: i64,
     pub metadata: Option<serde_json::Value>,
+    pub kit_de_armado: Option<KitDeArmado>,
 }
 
 #[derive(Debug, Clone, Serialize, Deserialize, Queryable, Insertable)]
diff --git a/rust-mev-engine/src/executor.rs b/rust-mev-engine/src/executor.rs
index d047d3e9..3251da86 100644
--- a/rust-mev-engine/src/executor.rs
+++ b/rust-mev-engine/src/executor.rs
@@ -11,6 +11,8 @@ use crate::config::Config;
 use crate::database::{Database, Execution};
 use crate::monitoring::Monitoring;
 use crate::rpc_manager::RpcManager;
+use crate::math_engine;
+use crate::types::{KitDeArmado, PoolReserves, DexFees, GasCostEstimator};
 
 // Flashbots bundle relay
 const FLASHBOTS_RELAY: &str = "https://relay.flashbots.net";
@@ -102,28 +104,25 @@ impl Executor {
         Ok(())
     }
 
-    async fn execute_atomic_arbitrage(
+        async fn execute_atomic_arbitrage(
         &self,
         execution: &Execution,
         config: &Config,
     ) -> Result<()> {
-        debug!("Executing atomic arbitrage: {}", execution.id);
-        
+        debug!("Executing atomic arbitrage with Kit de Armado: {}", execution.id);
+
         let chain = &execution.chain;
-        let provider = self.rpc_manager.get_provider(chain).await?;
-        
-        // Build arbitrage transaction
-        let tx = self.build_arbitrage_transaction(execution, config).await?;
-        
-        // Execute based on configuration
-        if config.execution.private_mempool {
-            // Send via Flashbots or other private relay
-            self.send_private_transaction(tx, chain, config).await?;
-        } else {
-            // Send via public mempool
-            self.send_public_transaction(tx, provider).await?;
-        }
-        
+
+        // Asegurarse de que el kit de armado está presente
+        let kit = execution.kit_de_armado.as_ref()
+            .ok_or_else(|| anyhow::anyhow!("Kit de Armado no encontrado para la ejecución {}", execution.id))?;
+
+        // Construir el bundle de transacciones a partir del kit de armado
+        let bundle = self.build_kit_de_armado_bundle(kit, config).await?;
+
+        // Enviar el bundle a través de un relay privado como Flashbots
+        self.send_flashbots_bundle(bundle, chain).await?;
+
         Ok(())
     }
 
@@ -283,7 +282,11 @@ impl Executor {
         // Set gas parameters
         let gas_price = self.gas_oracle.get_gas_price(&execution.chain).await?;
         tx = tx.gas_price(gas_price);
-        tx = tx.gas(U256::from(500000));
+        
+        // Simulate transaction to estimate gas more accurately
+        let simulated_tx = tx.clone().into();
+        let (estimated_gas_used, _) = self.simulate_transaction(&simulated_tx, &execution.chain).await?;
+        tx = tx.gas(estimated_gas_used + U256::from(50000)); // Add a buffer
         
         // Get nonce
         let nonce = self.nonce_tracker.write().await.get_next_nonce(&execution.chain).await?;
@@ -469,37 +472,113 @@ impl Executor {
         
         info!("Sent public transaction: {:?}", tx_hash);
         self.monitoring.increment_transactions_sent();
+
+        // Wait for transaction receipt to check status
+        match pending_tx.await {
+            Ok(Some(receipt)) => {
+                if receipt.status == Some(1.into()) { // 1 means success
+                    self.monitoring.increment_transactions_successful();
+                    info!("Public transaction successful: {:?}", tx_hash);
+                } else {
+                    self.monitoring.increment_reverted_transactions();
+                    warn!("Public transaction reverted: {:?}", tx_hash);
+                }
+            },
+            Ok(None) => {
+                self.monitoring.increment_transactions_failed();
+                warn!("Public transaction not found after sending: {:?}", tx_hash);
+            },
+            Err(e) => {
+                self.monitoring.increment_transactions_failed();
+                error!("Error waiting for public transaction receipt {:?}: {}", tx_hash, e);
+            }
+        }
         
         Ok(tx_hash)
+
     }
 
-    async fn send_private_transaction(
+      async fn send_private_transaction(
         &self,
         tx: TypedTransaction,
         chain: &str,
         config: &Config,
     ) -> Result<H256> {
-        // Send to configured relays
+        info!("Sending private transaction on {}", chain);
+        self.monitoring.increment_transactions_sent();
+
+        let mut last_error: Option<String> = None;
+
         for relay in &config.execution.relays {
             match relay.as_str() {
                 "flashbots" => {
-                    if let Ok(hash) = self.send_to_flashbots(tx.clone(), chain).await {
-                        return Ok(hash);
+                    if config.execution.flashbots_enabled {
+                        match self.send_to_flashbots(tx.clone(), chain).await {
+                            Ok(hash) => return Ok(hash),
+                            Err(e) => {
+                                error!("Flashbots relay failed: {}", e);
+                                last_error = Some(e.to_string());
+                            }
+                        }
                     }
                 }
                 "bloxroute" => {
-                    if let Ok(hash) = self.send_to_bloxroute(tx.clone(), chain).await {
-                        return Ok(hash);
+                    if config.execution.bloxroute_enabled {
+                        match self.send_to_bloxroute(tx.clone(), chain).await {
+                            Ok(hash) => return Ok(hash),
+                            Err(e) => {
+                                error!("Bloxroute relay failed: {}", e);
+                                last_error = Some(e.to_string());
+                            }
+                        }
                     }
                 }
-                "mev-share" => {
-                    if let Ok(hash) = self.send_to_mev_share(tx.clone(), chain).await {
-                        return Ok(hash);
+                "mev_share" => {
+                    if config.execution.mev_share_enabled {
+                        match self.send_to_mev_share(tx.clone(), chain).await {
+                            Ok(hash) => return Ok(hash),
+                            Err(e) => {
+                                error!("MEV-Share relay failed: {}", e);
+                                last_error = Some(e.to_string());
+                            }
+                        }
                     }
                 }
-                _ => {}
+                _ => {
+                    warn!("Unknown private relay configured: {}", relay);
+                }
             }
         }
+
+        if let Some(err_msg) = last_error {
+            self.monitoring.increment_reverted_transactions();
+            Err(anyhow::anyhow!("All private relays failed: {}", err_msg))
+        } else {
+            self.monitoring.increment_reverted_transactions();
+            Err(anyhow::anyhow!("No private relays enabled or configured"))
+        }
+    }
+                        Ok(hash) => {
+                            self.monitoring.increment_transactions_sent();
+                            info!("Sent private transaction via Flashbots: {:?}", hash);
+                            return Ok(hash);
+                        },
+                        Err(e) => {
+                            self.monitoring.increment_transactions_failed();
+                            error!("Failed to send private transaction via Flashbots: {}", e);
+                        }
+                    }
+                }
+                "bloxroute" => {
+                    // Similar logic for bloxroute
+                    self.monitoring.increment_transactions_failed(); // Placeholder for now
+                }
+                _ => {
+                    warn!("Unknown private relay configured: {}");
+                }
+            }
+        }
+        Err(anyhow::anyhow!("All private relays failed or no valid relay configured"))   }
         
         anyhow::bail!("Failed to send private transaction to any relay")
     }
@@ -595,4 +674,51 @@ struct Bundle {
     block_number: u64,
     min_timestamp: Option<u64>,
     max_timestamp: Option<u64>,
-}
\ No newline at end of file
+}
+
+
+    async fn build_kit_de_armado_bundle(
+        &self,
+        kit: &KitDeArmado,
+        config: &Config,
+    ) -> Result<Vec<TypedTransaction>> {
+        let mut bundle = Vec::new();
+
+        for step in &kit.pasos {
+            let mut tx = TransactionRequest::new();
+            tx = tx.to(step.contrato.parse::<Address>()?);
+            tx = tx.value(step.valor.parse::<U256>()?);
+            tx = tx.data(step.calldata.parse::<Bytes>()?);
+
+            // Configurar gas y nonce (esto es una simplificación)
+            let gas_price = self.gas_oracle.get_gas_price(&kit.chain).await?;
+            tx = tx.gas_price(gas_price);
+            tx = tx.gas(U256::from(500000)); // Gas estimado por paso
+
+            bundle.push(tx.into());
+        }
+
+        Ok(bundle)
+    }
+
+
+
+
+    async fn simulate_transaction(
+        &self,
+        tx: &TypedTransaction,
+        chain: &str,
+    ) -> Result<(U256, U256)> { // Returns (estimated_gas_used, estimated_profit)
+        let provider = self.rpc_manager.get_provider(chain).await?;
+
+        // Estimate gas usage
+        let gas_used = provider.estimate_gas(tx).await
+            .context("Failed to estimate gas for transaction")?;
+
+        // For profit estimation, we would need to run a local EVM fork or a more sophisticated simulation
+        // For now, we'll return a placeholder profit based on the opportunity's estimated profit
+        // In a real scenario, this would involve replaying the transaction on a local fork
+        // and analyzing the state changes.
+        Ok((gas_used, U256::zero())) // Placeholder for profit
+    }
+
diff --git a/rust-mev-engine/src/lib.rs b/rust-mev-engine/src/lib.rs
index 68a7d172..ac88272f 100644
--- a/rust-mev-engine/src/lib.rs
+++ b/rust-mev-engine/src/lib.rs
@@ -1,13 +1,21 @@
-// Library crate for MEV Engine modules
-#[cfg(feature = "scanners")]
-pub mod types;
-#[cfg(feature = "scanners")]
-pub mod scanners;
-#[cfg(feature = "scanners")]
+pub mod address_validator;
+pub mod config;
+pub mod data_fetcher;
+pub mod database;
+pub mod executor;
 pub mod graph;
-#[cfg(feature = "scanners")]
-pub mod sizing;
-#[cfg(feature = "scanners")]
 pub mod logging;
-#[cfg(feature = "scanners")]
+pub mod main;
+pub mod math_engine;
+pub mod mev_scanner;
+pub mod minimal;
+pub mod monitoring;
+pub mod multicall;
+pub mod opportunity_detector;
+pub mod rpc_health;
+pub mod rpc_manager;
+pub mod scanners;
 pub mod simulate;
+pub mod sizing;
+pub mod types;
+
diff --git a/rust-mev-engine/src/mev_scanner.rs b/rust-mev-engine/src/mev_scanner.rs
index 7cc61d49..b1fb61de 100644
--- a/rust-mev-engine/src/mev_scanner.rs
+++ b/rust-mev-engine/src/mev_scanner.rs
@@ -12,7 +12,12 @@ use crate::config::Config;
 use crate::database::{Database, Opportunity};
 use crate::monitoring::Monitoring;
 use crate::multicall::{MulticallManager, PriceResult};
+use crate::data_fetcher::DataFetcher;
 use crate::rpc_manager::RpcManager;
+use crate::math_engine;
+use crate::math_engine;
+use crate::types::{PoolReserves, DexFees, GasCostEstimator};
+use crate::address_validator::AddressValidator;
 
 pub struct MevScanner {
     rpc_manager: Arc<RpcManager>,
@@ -21,6 +26,8 @@ pub struct MevScanner {
     config: Arc<RwLock<Config>>,
     multicall: Arc<MulticallManager>,
     dex_registry: DexRegistry,
+    address_validator: AddressValidator,
+    data_fetcher: DataFetcher,
 }
 
 impl MevScanner {
@@ -37,6 +44,8 @@ impl MevScanner {
             config,
             multicall: Arc::new(MulticallManager::new()),
             dex_registry: DexRegistry::new(),
+            address_validator: AddressValidator::new(),
+            data_fetcher: DataFetcher::new(rpc_manager.clone()),
         }
     }
 
@@ -205,7 +214,14 @@ impl MevScanner {
         tx: &Transaction,
     ) -> Option<Opportunity> {
         // Check if transaction is a large swap on a known DEX
-        if !self.dex_registry.is_dex_router(&tx.to?) {
+                if let Some(to_addr) = tx.to {
+            if !self.address_validator.is_address_safe(&to_addr).await {
+                return None;
+            }
+            if !self.dex_registry.is_dex_router(&to_addr) {
+                return None;
+            }
+        } else {
             return None;
         }
 
@@ -245,7 +261,14 @@ impl MevScanner {
         // Check if transaction creates an arbitrage opportunity
         // For example, after a large swap that moves the price
         
-        if !self.dex_registry.is_dex_router(&tx.to?) {
+        if let Some(to_addr) = tx.to {
+            if !self.address_validator.is_address_safe(&to_addr).await {
+                return None;
+            }
+            if !self.dex_registry.is_dex_router(&to_addr) {
+                return None;
+            }
+        } else {
             return None;
         }
 
@@ -277,7 +300,14 @@ impl MevScanner {
         // Check if transaction is adding/removing liquidity from Uniswap V3
         let uniswap_v3_positions = "0xC36442b4a4522E871399CD717aBDD847Ab11FE88".parse::<Address>().ok()?;
         
-        if tx.to != Some(uniswap_v3_positions) {
+        if let Some(to_addr) = tx.to {
+            if !self.address_validator.is_address_safe(&to_addr).await {
+                return None;
+            }
+            if to_addr != uniswap_v3_positions {
+                return None;
+            }
+        } else {
             return None;
         }
 
@@ -318,24 +348,65 @@ impl MevScanner {
                 // Find arbitrage opportunities
                 for i in 0..prices.len() {
                     for j in i+1..prices.len() {
-                        let price_diff = (prices[i].1 - prices[j].1).abs() / prices[i].1;
-                        
-                        if price_diff > 0.015 { // 1.5% difference
+                    // Aquí integramos el cálculo diferencial para encontrar la cantidad óptima y el beneficio
+                    // Esto es una simplificación. En un bot real, se necesitarían las reservas reales de los pools
+                    // y se modelaría la función de beneficio de forma más precisa.
+
+                    // Obtener reservas de pools en tiempo real usando DataFetcher
+                    let pool1_reserves = match self.data_fetcher.get_pool_reserves(chain, &prices[i].0, &token0, &token1).await {
+                        Ok(res) => res,
+                        Err(e) => {
+                            warn!("Failed to get pool1 reserves for {}/{}: {}", token0, token1, e);
+                            continue;
+                        }
+                    };
+                    let pool2_reserves = match self.data_fetcher.get_pool_reserves(chain, &prices[j].0, &token1, &token0).await {
+                        Ok(res) => res,
+                        Err(e) => {
+                            warn!("Failed to get pool2 reserves for {}/{}: {}", token1, token0, e);
+                            continue;
+                        }
+                    };
+                    let dex_fees = DexFees { fee_rate_pool1: 0.003, fee_rate_pool2: 0.003 };
+                    let gas_estimator = GasCostEstimator { fixed_cost: 20.0 }; // Costo de gas en USD
+
+                    let profit_function = |x_in: f64| {
+                        math_engine::calculate_profit(
+                            x_in,
+                            &pool1_reserves,
+                            &pool2_reserves,
+                            &dex_fees,
+                            &gas_estimator,
+                        )
+                    };
+
+                    let initial_guess = 1.0; // Cantidad inicial de Token A a probar (ej. 1 WETH)
+                    let tolerance = 1e-6;
+                    let max_iterations = 1000;
+                    let step_size = 0.1;
+
+                    if let Some(optimal_x) = math_engine::find_optimal_x(profit_function, initial_guess, tolerance, max_iterations, step_size) {
+                        let max_profit = profit_function(optimal_x);
+
+                        if max_profit > 0.0 { // Umbral de beneficio mínimo
+                            info!("Arbitrage opportunity detected: {} -> {} (Optimal Amount: {:.6}, Profit: {:.6} USD)", prices[i].0, prices[j].0, optimal_x, max_profit);
+
                             let opp = Opportunity {
-                                id: format!("arb_{}_{}_{}", chain, token0, chrono::Utc::now().timestamp_millis()),
+                                id: format!("arb_{}_{}_{}", chain, prices[i].0, prices[j].0),
                                 chain_id: chain_id as i32,
                                 strategy: "dex-arb".to_string(),
                                 dex_in: prices[i].0.clone(),
                                 dex_out: prices[j].0.clone(),
                                 base_token: token0.clone(),
                                 quote_token: token1.clone(),
-                                amount_in: "1000000000000000000".to_string(), // 1 ETH
-                                est_profit_usd: price_diff * 3000.0, // Rough estimate
-                                gas_usd: 20.0,
+                                amount_in: optimal_x.to_string(), // Cantidad óptima calculada
+                                est_profit_usd: max_profit,
+                                gas_usd: gas_estimator.estimate_cost(optimal_x),
                                 ts: chrono::Utc::now().timestamp_millis(),
                                 metadata: serde_json::json!({
                                     "type": "dex-arb",
-                                    "price_diff_pct": price_diff * 100.0,
+                                    "optimal_amount_in": optimal_x,
+                                    "estimated_profit_usd": max_profit,
                                 }),
                             };
                             
@@ -343,6 +414,17 @@ impl MevScanner {
                                 error!("Failed to save arbitrage opportunity: {}", e);
                             }
                         }
+                    } else { 
+                            debug!("No profitable opportunity after optimization for {} -> {}", prices[i].0, prices[j].0);
+                        }
+                    } else {
+                        debug!("Could not find optimal amount for arbitrage opportunity: {} -> {}", prices[i].0, prices[j].0);
+                    }                   } else { 
+                            debug!("No profitable opportunity after optimization for {} -> {}", prices[i].0, prices[j].0);
+                        }
+                    } else {
+                        debug!("Could not find optimal amount for arbitrage opportunity: {} -> {}", prices[i].0, prices[j].0);
+                    }
                     }
                 }
             }
diff --git a/rust-mev-engine/src/monitoring.rs b/rust-mev-engine/src/monitoring.rs
index d61132bf..20383ef0 100644
--- a/rust-mev-engine/src/monitoring.rs
+++ b/rust-mev-engine/src/monitoring.rs
@@ -17,6 +17,8 @@ pub struct Monitoring {
     transactions_successful: Counter,
     transactions_failed: Counter,
     bundles_sent: Counter,
+    validation_failures: Counter,
+    reverted_transactions: Counter,
     
     // Gauges
     active_opportunities: Gauge,
@@ -86,6 +88,16 @@ impl Monitoring {
             "Total number of bundles sent to relays"
         ).expect("Failed to register bundles_sent counter");
         
+        let validation_failures = register_counter!(
+            "mev_validation_failures_total",
+            "Total number of validation failures"
+        ).expect("Failed to register validation_failures counter");
+        
+        let reverted_transactions = register_counter!(
+            "mev_reverted_transactions_total",
+            "Total number of reverted transactions"
+        ).expect("Failed to register reverted_transactions counter");
+        
         let active_opportunities = register_gauge!(
             "mev_active_opportunities",
             "Number of currently active opportunities"
@@ -154,6 +166,8 @@ impl Monitoring {
             transactions_successful,
             transactions_failed,
             bundles_sent,
+            validation_failures,
+            reverted_transactions,
             active_opportunities,
             pending_executions,
             total_profit_usd,
@@ -191,6 +205,14 @@ impl Monitoring {
     pub fn increment_bundles_sent(&self) {
         self.bundles_sent.inc();
     }
+
+    pub fn increment_validation_failures(&self) {
+        self.validation_failures.inc();
+    }
+
+    pub fn increment_reverted_transactions(&self) {
+        self.reverted_transactions.inc();
+    }
     
     // Gauge methods
     pub fn set_active_opportunities(&self, count: f64) {
diff --git a/rust-mev-engine/src/types.rs b/rust-mev-engine/src/types.rs
index 3afdf10d..fd6c9e58 100644
--- a/rust-mev-engine/src/types.rs
+++ b/rust-mev-engine/src/types.rs
@@ -39,3 +39,123 @@ pub struct ScanConfig {
     #[serde(default, alias = "post_api_key")]
     pub postApiKey: Option<String>,
 }
+
+
+use ethers::types::Address;
+
+// Representación de una Blockchain
+#[derive(Debug, Clone)]
+pub struct Blockchain {
+    pub id: String,
+    pub name: String,
+    pub rpc_url: String,
+    pub chain_id: u64,
+    pub dex_protocols: Vec<DexProtocol>,
+    pub monitored_assets: Vec<Asset>,
+}
+
+// Representación de un Protocolo DEX
+#[derive(Debug, Clone)]
+pub struct DexProtocol {
+    pub id: String,
+    pub name: String,
+    pub router_address: Address, // Dirección del router del DEX
+    pub factory_address: Address, // Dirección de la fábrica de pools
+    // Otros detalles específicos del DEX (ej. tipo de AMM, fees)
+    pub fee_rate: f64, // Tasa de comisión por swap
+}
+
+// Representación de un Activo (Token)
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+pub struct Asset {
+    pub symbol: String,
+    pub address: Address,
+    pub decimals: u8,
+    pub price_usd: f64, // Precio en tiempo real
+}
+
+// Representación de un Pool de Liquidez
+#[derive(Debug, Clone)]
+pub struct LiquidityPool {
+    pub address: Address,
+    pub token0: Asset,
+    pub token1: Asset,
+    pub reserve0: f64,
+    pub reserve1: f64,
+    pub fee: f64,
+    pub dex_id: String, // ID del DEX al que pertenece
+}
+
+// Una operación atómica dentro de un kit de armado
+#[derive(Debug, Clone)]
+pub enum ArbitrageOperation {
+    Flashloan {
+        token: Asset,
+        amount: f64,
+        provider: String,
+        provider_address: Address,
+    },
+    Swap {
+        dex: DexProtocol,
+        token_in: Asset,
+        amount_in: f64,
+        token_out: Asset,
+        min_amount_out: f64,
+        pool_address: Address,
+    },
+    Liquidation {
+        protocol: String,
+        protocol_address: Address,
+        collateral: Asset,
+        debt: Asset,
+        amount_to_liquidate: f64,
+    },
+    // ... otras operaciones
+}
+
+// Un Kit de Armado de Arbitraje
+#[derive(Debug, Clone)]
+pub struct ArbitrageKit {
+    pub id: String,
+    pub operations: Vec<ArbitrageOperation>,
+    pub estimated_profit: f64,
+    pub estimated_gas_cost: f64,
+    pub blockchain_id: String,
+    pub timestamp: u64,
+    pub validated_addresses: HashMap<String, Address>, // Direcciones validadas para el kit
+}
+
+// HashMap para almacenar y acceder rápidamente a los datos
+pub type BlockchainMap = HashMap<String, Blockchain>;
+pub type DexProtocolMap = HashMap<String, DexProtocol>;
+pub type AssetMap = HashMap<String, Asset>;
+pub type LiquidityPoolMap = HashMap<String, LiquidityPool>;
+
+
+
+// Estructuras para el motor matemático
+#[derive(Debug, Clone)]
+pub struct PoolReserves {
+    pub reserve_a: f64,
+    pub reserve_b: f64,
+}
+
+#[derive(Debug, Clone)]
+pub struct DexFees {
+    pub fee_rate_pool1: f64,
+    pub fee_rate_pool2: f64,
+}
+
+#[derive(Debug, Clone)]
+pub struct GasCostEstimator {
+    pub fixed_cost: f64,
+}
+
+
+impl GasCostEstimator {
+    pub fn estimate_cost(&self, _x_in: f64) -> f64 {
+        // En un bot real, esto sería dinámico y dependería de x_in y la congestión de la red
+        self.fixed_cost
+    }
+}
+
diff --git a/rust-mev-engine/target/.rustc_info.json b/rust-mev-engine/target/.rustc_info.json
index e3fde857..130b5648 100644
--- a/rust-mev-engine/target/.rustc_info.json
+++ b/rust-mev-engine/target/.rustc_info.json
@@ -1 +1 @@
-{"rustc_fingerprint":16858092026277685496,"outputs":{"7971740275564407648":{"success":true,"status":"","code":0,"stdout":"___\nlib___.rlib\nlib___.so\nlib___.so\nlib___.a\nlib___.so\n/nix/store/bqwc4hzm2lvshv5i3y9l3rmsb17z9a57-rust-mixed\noff\npacked\nunpacked\n___\ndebug_assertions\npanic=\"unwind\"\nproc_macro\ntarget_abi=\"\"\ntarget_arch=\"x86_64\"\ntarget_endian=\"little\"\ntarget_env=\"gnu\"\ntarget_family=\"unix\"\ntarget_feature=\"fxsr\"\ntarget_feature=\"sse\"\ntarget_feature=\"sse2\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"linux\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"unknown\"\nunix\n","stderr":""},"17747080675513052775":{"success":true,"status":"","code":0,"stdout":"rustc 1.88.0 (6b00bc388 2025-06-23)\nbinary: rustc\ncommit-hash: 6b00bc3880198600130e1cf62b8f8a93494488cc\ncommit-date: 2025-06-23\nhost: x86_64-unknown-linux-gnu\nrelease: 1.88.0\nLLVM version: 20.1.5\n","stderr":""},"2951655959503346277":{"success":true,"status":"","code":0,"stdout":"___\nlib___.rlib\nlib___.so\nlib___.so\nlib___.a\nlib___.so\n/nix/store/bqwc4hzm2lvshv5i3y9l3rmsb17z9a57-rust-mixed\noff\npacked\nunpacked\n___\ndebug_assertions\npanic=\"unwind\"\nproc_macro\ntarget_abi=\"\"\ntarget_arch=\"x86_64\"\ntarget_endian=\"little\"\ntarget_env=\"gnu\"\ntarget_family=\"unix\"\ntarget_feature=\"fxsr\"\ntarget_feature=\"sse\"\ntarget_feature=\"sse2\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"linux\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"unknown\"\nunix\n","stderr":""},"4519493916264270397":{"success":true,"status":"","code":0,"stdout":"___\nlib___.rlib\nlib___.so\nlib___.so\nlib___.a\nlib___.so\n/nix/store/bqwc4hzm2lvshv5i3y9l3rmsb17z9a57-rust-mixed\noff\npacked\nunpacked\n___\ndebug_assertions\npanic=\"unwind\"\nproc_macro\ntarget_abi=\"\"\ntarget_arch=\"x86_64\"\ntarget_endian=\"little\"\ntarget_env=\"gnu\"\ntarget_family=\"unix\"\ntarget_feature=\"fxsr\"\ntarget_feature=\"sse\"\ntarget_feature=\"sse2\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"linux\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"unknown\"\nunix\n","stderr":""}},"successes":{}}
\ No newline at end of file
+{"rustc_fingerprint":13915158586454731970,"outputs":{"4519493916264270397":{"success":true,"status":"","code":0,"stdout":"___\nlib___.rlib\nlib___.so\nlib___.so\nlib___.a\nlib___.so\n/home/ubuntu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu\noff\npacked\nunpacked\n___\ndebug_assertions\npanic=\"unwind\"\nproc_macro\ntarget_abi=\"\"\ntarget_arch=\"x86_64\"\ntarget_endian=\"little\"\ntarget_env=\"gnu\"\ntarget_family=\"unix\"\ntarget_feature=\"fxsr\"\ntarget_feature=\"sse\"\ntarget_feature=\"sse2\"\ntarget_has_atomic=\"16\"\ntarget_has_atomic=\"32\"\ntarget_has_atomic=\"64\"\ntarget_has_atomic=\"8\"\ntarget_has_atomic=\"ptr\"\ntarget_os=\"linux\"\ntarget_pointer_width=\"64\"\ntarget_vendor=\"unknown\"\nunix\n","stderr":""},"17747080675513052775":{"success":true,"status":"","code":0,"stdout":"rustc 1.90.0 (1159e78c4 2025-09-14)\nbinary: rustc\ncommit-hash: 1159e78c4747b02ef996e55082b704c09b970588\ncommit-date: 2025-09-14\nhost: x86_64-unknown-linux-gnu\nrelease: 1.90.0\nLLVM version: 20.1.8\n","stderr":""}},"successes":{}}
\ No newline at end of file
